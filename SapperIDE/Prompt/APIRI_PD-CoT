Follow the steps below to infer the API relations between the two apis.

1. Extract the Non-fully qualified names and fully qualified names of the API in the text.
2. Then resolve the API's Non-fully qualified names to the fully qualified names (FQNs).
3. Combine all FQNS in pairs.
4. Infer the relations between the two apis based on their features.
-4.1: If two apis have similar usage, then there is a function similarity relation;
-4.2: If two apis have similar usage and different behaviors, then there is a behavior difference relation;
-4.3: If an API can be replaced by another API in a certain scenario, then there is a function replace relation;
-4.4: If an API needs to be called before or after other API, then there is a logic constraint relation;
-4.5: If two APIs have an efficiency comparison in some specific conditions, there is an efficiency comparison;
-4.6: If none of the above exists, it is unknown.

text:
Summary arraylist with arraydeque are preferable in many more use-cases than linkedlist.
If you're not sure — just start with arrayList.
Non-fully qualified names: arraylist, arraydeque,linkedlist;
FQNS: java.util.arraylist, java.util.arraydeque, java.util.linkedlist;
relation:
(java.util.arraylist, java.util.arraydeque) : function similarity, behavior difference, efficiency comparison
(java.util.arraydeque, java.util.linkedlist): function similarity, behavior difference, efficiency comparison
(java.util.arraylist, java.util.linkedlist): function similarity, behavior difference, efficiency comparison

text:
One of hashMap's subclasses is linkedhashmap, so in the event that you'd want predictable iteration order (which is insertion order by default), you could easily wsap out the hashmap for a linkedhashmap. This wouldn't be as easy if you were using hashtable.
Non-fully qualified names: hashMap, linkedhashmap, hashtable;
FQNS: java.util.hashmap, java.util.linkedhashmap, java.util.hashtable;
relation:
(java.util.hashmap, java.util.linkedhashmap): function similarity, behavior difference, function replace, efficiency comparison
(java.util.hashmap, java.util.hashtable): function similarity, behavior difference, function replace, efficiency comparison
(java.util.linkedhashmap, java.util.hashtable): function similarity, behavior difference, function replace, efficiency comparison

text:
The higherentry() does the opposite of the lowerentry(), meaning higherentry() returns a key-value mapping associated with the least key strictly greater than the given key, or null if there is no such key.
Non-fully qualified names: higherentry(), lowerentry();
FQNS: java.treemap.higherentry, java.treemap.lowerentry;
relation:
(java.treemap.higherentry, java.treemap.lowerentry): unknow

text:
matches returns true if the whole string matches the given pattern. find tries to find a substring that matches the pattern.
Non-fully qualified names: matches, find;
FQNS: java.util.regex.matches,  java.util.regex.find;
relation:
(java.util.regex.matches,  java.util.regex.find): function similarity, behavior difference, function  replace

text:
StringBuilder was added in Java 5. For versions prior to Java 5, the StringBuffer class can be used instead — it has the same API.
Non-fully qualified names: stringbuilder, stringbuffer
FQNS: java.lang.stringbuilder, java.lang.stringbuffer
relation:
(java.lang.stringbuilder, java.lang.stringbuffer): function similarity, behavior difference, function  replace, efficiency comparison

sentence:
{{sentence}}