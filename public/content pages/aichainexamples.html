<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>AIChain example</title>
    <!-- bootstrap -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4" crossorigin="anonymous"></script>
    <!-- icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.2/font/bootstrap-icons.css">
    <!-- jquery -->
    <script src="../plugin/jquery.min.js"></script>
    <!-- self-defined -->
    <link href="content.css" rel="stylesheet">
    <script src="content.js"></script>
</head>
<body>
<!-- navbar -->
<nav class="navbar navbar-expand-lg navbar-light my-navbar">
  <a class="navbar-brand" href="#cover">AI Chain</a>
  <div class="collapse navbar-collapse" id="navbarNav">
    <ul class="navbar-nav">
      <li class="nav-item">
        <a class="nav-link" href="#aichain">Chain</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="#promptmanship">Promptmanship</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="#sapper">Sapper</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" href="#about">About Us</a>
      </li>
    </ul>
  </div>
</nav>

<main>
    <div id="main-content">
        <h1 class="main-title">AI Chain Examples in the Literature</h1>
        <h2 class="main-subtitle"></h2>
        
        <p>
            The concept of AI chain has been widely applied in various scenarios recently. Here, we provide several typical examples that we have learned about (please let us know if we have missed any important work). 
            We categorize these works into three major categories: <b>task-specific AI chains</b>, <b>task-agnostic agent frameworks</b>, <b>AI chain programming support</b>.
            Our Prompt Sapper draws inspiration from these projects and tools, but it has <a href="sappervsothers.html">significant differences</a> from them in terms of balanced human-AI teamwork, low requirments for computing and programming skills, and systematic support for AI4SE4AI.
        </p>

        <h2 class="main-subtitle">Task Specific AI Chains</h2>
        <p> 
            <a href="https://arxiv.org/abs/2210.02441">Ask Me Anything: A simple strategy for prompting language models </a>
        </p>

        <img class="main-figure" src="../image/figures/ama.jpg">
        <p class="figure-caption">Ask Me Anything</p>

        <p>
            The research proposes a new method called "ASK ME ANYTHING (AMA)" for generating natural language prompts to train Large Language Models (LLMs) on new tasks. The approach involves producing multiple effective prompts, including question-answering formats, and using weak supervision to combine the noisy predictions. The proposed method shows an average performance lift of 10.2% over the few-shot baseline and enables GPT-J-6B model to outperform few-shot GPT3-175B on 15 of 20 popular benchmarks.
        </p>
        
        <p> 
            <a href="https://arxiv.org/abs/2208.11663">PEER: A Collaborative Language Model </a>
        </p>

        <img class="main-figure" src="../image/figures/PEER.jpg">
        <p class="figure-caption">PEER</p>

        <p>
            The research paper introduces PEER, a collaborative language model that imitates the entire writing process, including writing drafts, proposing edits, and providing explanations. It addresses the shortcomings of existing language models in collaborative writing by enabling them to update existing texts, control text generation, and explain their actions. Multiple instances of PEER can infill various parts of the writing process, allowing self-training to increase the quality, amount, and diversity of training data. The model shows strong performance across various domains and editing tasks.
        </p>
        
        <p> 
            <a href="https://arxiv.org/abs/2210.06774">Re3: Generating Longer Stories With Recursive Reprompting and Revision</a>
        </p>

        <div style="width: 100%; text-align: center">
            <img class="main-figure" style="width: 60%" src="../image/figures/Re3.jpg">
        </div>
        <p class="figure-caption">Re3</p>

        <p>
            The paper proposes a Recursive Reprompting and Revision (Re3) framework for generating long-form stories. Re3 uses a general-purpose language model to create an overarching plan and generate story passages. The passages are then revised for plot coherence and premise relevance, and the best continuation is edited for factual consistency. Compared to similar-length stories generated directly from the same model, Re3's stories were judged to have a more coherent plot and to be more relevant to the initial premise by human evaluators.
        </p>
        
        <p> 
            <a href="https://arxiv.org/abs/2205.09712">Selection-Inference: Exploiting Large Language Models for Interpretable Logical Reasoning</a>
        </p>

        <img class="main-figure" src="../image/figures/SI.jpg">
        <p class="figure-caption">Selection-Inference</p>

        <p>
            This research evaluates the performance of large language models (LLMs) on logical reasoning tasks and proposes a Selection-Inference (SI) framework to improve their ability to solve complex problems. The framework utilizes pre-trained LLMs and alternates between selection and inference to generate a series of interpretable, causal reasoning steps. The proposed SI framework outperforms vanilla baselines and yields a performance improvement of over 100% in a 5-shot generalization setting, even outperforming a larger baseline. Additionally, the framework generates reasoning traces to improve the safety and trustworthiness of the system.
        </p>
        
        <p> 
            <a href="https://arxiv.org/abs/2212.13894">LAMBADA: Backward Chaining for Automated Reasoning in Natural Language</a>
        </p>

        <div style="width: 100%; text-align: center">
            <img class="main-figure" style="width: 50%" src="../image/figures/lambada.jpg">
        </div>
        <p class="figure-caption">LAMBADA</p>

        <p>
            The paper discusses automated reasoning with natural language texts by using large language models. It introduces a backward chaining algorithm, called LAMBADA, which decomposes reasoning into four sub-modules to efficiently search for proofs. LAMBADA significantly outperforms state-of-the-art forward reasoning methods on two challenging logical reasoning datasets.
        </p>
        
        <p> 
            <a href="https://arxiv.org/abs/2209.11302">ProgPrompt: Generating Situated Robot Task Plans using Large Language Models</a>
        </p>

        <img class="main-figure" src="../image/figures/ProgPrompt.jpg">
        <p class="figure-caption">ProgPrompt</p>

        <p>
            The paper introduces a method of using large language models (LLMs) to plan robot actions for various tasks in a situated environment. By prompting the LLM with program-like specifications of available actions and objects, and with example programs, the system can generate action sequences that are functional across different environments and robot capabilities. The method achieves state-of-the-art success rates in household tasks and is demonstrated on a physical robot arm for tabletop tasks.
        </p>
        
        <p> 
            <a href="../paper/PCR_Chain.pdf">PCR-Chain: Partial Code Reuse Assisted by Hierarchical Chaining of Prompts on Frozen Copilot</a>
        </p>

        <img class="main-figure" src="../image/figures/pcrchain.jpg">
        <p class="figure-caption">PCR_Chain</p>

        <p>
            The research paper proposes PCR-Chain, a method for reusing partial code from API documentation, technical blogs, and programming Q&A sites. PCR-Chain resolves fully qualified names and fixes syntax errors using a pre-trained code model and in-context learning. The paper outlines the underlying prompt architecture and design and demonstrates the high success rate of the method in automatically resolving FQNs and fixing syntax errors in partial code samples.
        </p>
        
        <p> 
            <a href="https://arxiv.org/abs/2303.17580">HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in Hugging Face</a>
        </p>

        <h2 class="main-subtitle">Task Agnostic Agent Frameworks</h2>
        <img class="main-figure" src="../image/figures/HuggingGPT.jpg">
        <p class="figure-caption">HuggingGPT</p>
        
        <p>
            In addition to specific tasks, AI chain is a powerful tool for multi-model, tool, and API collaboration to solve complex tasks involving multi-modal subtasks.
        </p>
        <p>
            <a href="https://arxiv.org/abs/2303.17580">HuggingGPT</a> is a typical example. 
            It regards large language models (LLMs) as a controller to manage existing AI models in different domains and modalities to solve complicated AI tasks. 
            As shwon in the above figure, it uses LLMs to conduct task planning, select appropriate AI models, execute subtasks, and summarize responses. 
            HuggingGPT shows impressive results in various challenging tasks, including language, vision, speech, and other modalities, demonstrating the potential of LLMs in advancing artificial intelligence.
        </p>
        <p>
            Technically, HuggingGPT is a task-agnostic autonomous agent framework.
            Many such agent frameworks have been proposed recently, such as <a href="https://openai.com/blog/chatgpt-plugins">ChatGPT Plugins</a>, <a href="https://github.com/reworkd/AgentGPT">AgentGPT</a>, <a href="https://github.com/microsoft/TaskMatrix">Visual-ChatGPT</a>, <a href="https://arxiv.org/abs/2303.16434">TaskMatrix.AI</a>, <a href="https://github.com/Significant-Gravitas/Auto-GPT">AutoGPT</a>, <a href="https://github.com/yoheinakajima/babyagi">BabyAGI</a>, <a href="https://github.com/alvarosevilla95/autolang">autolang</a>, <a href="https://github.com/lightaime/camel">CAMEL</a>, <a href="https://hyperwriteai.com/">HyperWriter AI</a>, <a href="https://www.codewand.co/">Codewand</a>, which some people argue are the step towards Artificial General Intelligence (AGI).
            In these frameworks, the LLM runs an AI chain to understand user input, divide and conquer the task, plan task sub-steps, map task steps to appropriate models, tools and APIs, coordinate the task execution, and aggregate the results from various steps.
            As such, AI can deal with much more complex tasks.
        </p>
        
        
        <h2 class="main-subtitle">AI Chain Programming Support</h2>        
        <p> 
            <a href="https://dl.acm.org/doi/abs/10.1145/3491102.3517582">AI Chains: Transparent and Controllable Human-AI Interaction by Chaining Large Language Model Prompts</a>
        </p>

        <img class="main-figure" src="../image/figures/AIChain.jpg">
        <p class="figure-caption">AI Chain Visual Programming</p>

        <p>
            This paper proposes to use visual programming to chain Large Language Model (LLM) steps together as a method to enhance the effectiveness of LLMs on complex tasks, while improving transparency, controllability and sense of collaboration. The paper defines a set of LLM primitive operations and presents an interactive system where users can create and modify these chains in a modular way (such as step b1/b2/b3 in the above figure). A user study found that chaining improved task outcomes, and users developed new ways of interacting with LLMs. The paper presents three case studies to explore how LLM chains can be used travel flashcard creation, visualization code debugging, and assisted text entry.
            The authors have published a series of works on the AI chain benefits, challenges and tool supports (see also their papers <a href="https://dl.acm.org/doi/abs/10.1145/3491101.3503564">PromptMaker</a> and <a href="https://dl.acm.org/doi/10.1145/3491101.3519729">PromptChainer</a>).
        </p>
        
        <p> 
            <a href="https://python.langchain.com/en/latest/index.html">LangChain Python Framework</a>
        </p>
        <img class="main-figure" src="../image/figures/langchain.jpg">
        <p class="figure-caption">LangChain Documentation</p>

        <p>
            In addition end-user oriented visual programming, several agent programming frameworks have also been proposed, such as <a href="https://dust.tt/">Dust</a>, <a href="https://primer.ought.org/">Primer</a>, and the most popular one, <a href="https://langchain.readthedocs.io/en/latest/index.html}">LangChain</a>, targeting at AI engineers and software developers.
            These frameworks encapsulate raw LLM and data APIs into explicit high-level concepts such as chains, agents, prompts, models, indexes, and streamline the model and data interactions, thus facilitating the development of task-specific AI chains and autonomous agent frameworks.
        </p>
    </div>
    <div id="page-nav-id" style="display: none">aichainexamples</div>
</main>

<!--<footer id="footer">-->
<!--</footer>-->

</body>
</html>
